package withings

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"time"
)

// HeartData is ECG and Afib classifications as returned by the Withings API.
type HeartData struct {
	DeviceID string `json:"deviceid"`
	Model    int64  `json:"model"`
	Ecg      struct {
		SignalID int64 `json:"signalid"`
		Afib     int64 `json:"afib"`
	} `json:"ecg"`
	BloodPressure struct {
		Diastole int64 `json:"diastole"`
		Systole  int64 `json:"systole"`
	} `json:"bloodpressure"`
	HeartRate int64 `json:"heart_rate"`
	Timestamp int64 `json:"timestamp"`
}

// HeartDatas is a slice of HeartData as returned by the Withings API.
type HeartDatas []HeartData

// GetHeartResp is the response type returned by the Withings API for are request for heart data.
type GetHeartResp struct {
	Status   int64        `json:"status"`
	APIError string       `json:"error"`
	Body     GetHeartBody `json:"body"`
}

// GetHeartBody is the body of the response returned by the Withings API for are request for heart data.
type GetHeartBody struct {
	Series HeartDatas `json:"series"`
	More   bool       `json:"more"`
	Offset int64      `json:"offset"`
}

// GetHeartListParam contains the parameters needed to request heart data.
type GetHeartListParam struct {

	// The start of the window of measurements to retrieve. This value is ignored if LastUpdate is provided.
	StartDate *time.Time

	// The end of the window of the measurements to retrieve. This value is ignored if LastUpdate is provided.
	EndDate *time.Time

	// An offset value used for paging. The API response will return more with a 1 value if there are more pages
	// to retrieve. Along with this an offset value is provided. That value should be provided here on the next
	// request. See the Withings documentation for more information.
	Offset int64
}

// UpdateQuery updates the query provided with the parameters of this param.
func (p *GetHeartListParam) UpdateQuery(q url.Values) url.Values {
	// Constructing the query parameters based on the param provided.
	q.Set("action", APIActionGetHeartList)
	if p.Offset > 0 {
		q.Set("offset", strconv.FormatInt(p.Offset, 10))
	}

	if p.StartDate != nil {
		q.Set("startdate", strconv.FormatInt(p.StartDate.Unix(), 10))
	}
	if p.EndDate != nil {
		q.Set("enddate", strconv.FormatInt(p.EndDate.Unix(), 10))
	}

	return q
}

// GetHeartList retrieves HeartData for the user represented by the token. Error will be non nil upon an internal
// or api error. If the API returned the error the response will contain the error.
func (c *Client) GetHeartList(ctx context.Context, token AccessToken, param GetHeartListParam) (*GetHeartResp, error) {

	// Construct authorized request to request data from the API.
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, APIHeartV2, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to build http request: %w", err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token.AccessToken))

	// Updating the query with the parameters generated by the param provided.
	req.URL.RawQuery = param.UpdateQuery(req.URL.Query()).Encode()

	// Executing the request.
	resp, err := c.HttpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read body of request: %w", err)
	}

	var mResp GetHeartResp
	if err = json.Unmarshal(body, &mResp); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	switch mResp.Status {
	case 0:
		return &mResp, nil
	default:
		return &mResp, fmt.Errorf("api returned an error: %s", mResp.APIError)
	}
}

// HeartHighFrequencyData is the high frequency heart data as specified by the Withings API.
type HeartHighFrequencyData struct {
	Signal            string `json:"signal"`
	SamplingFrequency int    `json:"sampling_frequency"`
	WearPosition      int    `json:"wearposition"`
}

// GetHeartHighFrequencyDataResp is the response type returned by the Withings API for are request for high frequency heart data.
type GetHeartHighFrequencyDataResp struct {
	Status   int64                  `json:"status"`
	APIError string                 `json:"error"`
	Body     HeartHighFrequencyData `json:"body"`
}

// GetHeartHighFrequencyDataParam contains the parameters needed to request high frequency heart data.
type GetHeartHighFrequencyDataParam struct {
	SignalID int64 `json:"signalid"`
}

// UpdateQuery updates the query provided with the parameters of this param.
func (p *GetHeartHighFrequencyDataParam) UpdateQuery(q url.Values) url.Values {
	// Constructing the query parameters based on the param provided.
	q.Set("action", APIActionGetHeartGet)
	q.Set("signalid", strconv.FormatInt(p.SignalID, 10))

	return q
}

// GetHeartHighFrequencyData retrieves high frequency HeartData for the user represented by the token. Error will be non nil upon an internal
// or api error. If the API returned the error the response will contain the error.
func (c *Client) GetHeartHighFrequencyData(ctx context.Context, token AccessToken, param GetHeartHighFrequencyDataParam) (*GetHeartHighFrequencyDataResp, error) {

	// Construct authorized request to request data from the API.
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, APIHeartV2, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to build http request: %w", err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token.AccessToken))

	// Updating the query with the parameters generated by the param provided.
	req.URL.RawQuery = param.UpdateQuery(req.URL.Query()).Encode()

	// Executing the request.
	resp, err := c.HttpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read body of request: %w", err)
	}

	var mResp GetHeartHighFrequencyDataResp
	if err = json.Unmarshal(body, &mResp); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	switch mResp.Status {
	case 0:
		return &mResp, nil
	default:
		return &mResp, fmt.Errorf("api returned an error: %s", mResp.APIError)
	}
}
