package withings

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strconv"
)

// SubscribeToNotificationsParam is the parameter needed to subscribe to a notification of updates.
type SubscribeToNotificationsParam struct {

	// The URL that the Withings service will call to send the notification.
	CallbackURL url.URL

	// The notification category. Please see the API for the proper values.
	Appli int

	// An optional comment.
	Comment string
}

// SubscribeToNotificationsResp is the response type returned by the Withings API when subscribing to a notification.
type SubscribeToNotificationsResp struct {
	Status   int64  `json:"status"`
	APIError string `json:"error"`
}

// UpdateQuery updates the query provided with the parameters of this param. The parameters require the ClientID
// of the client subscribing.
func (p *SubscribeToNotificationsParam) UpdateQuery(q url.Values, clientID string) url.Values {
	// Constructing the query parameters based on the param provided.
	q.Set("action", APIActionNotificationSubscribe)
	q.Set("appli", strconv.Itoa(p.Appli))
	q.Set("client_id", clientID)
	q.Set("callbackurl", p.CallbackURL.String())
	if p.Comment != "" {
		q.Set("comment", p.Comment)

	}

	return q
}

// SubscribeToNotifications subscribes to receiving notifications for various events. If the subscription is successful
// the error will be nil.
func (c *Client) SubscribeToNotifications(ctx context.Context, token AccessToken, param SubscribeToNotificationsParam) (*SubscribeToNotificationsResp, error) {

	// Construct authorized request to request data from the API.
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, APINotify, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to build http request: %w", err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token.AccessToken))

	// Updating the query with the parameters generated by the param provided.
	req.URL.RawQuery = param.UpdateQuery(req.URL.Query(), c.clientID).Encode()

	// Executing the request.
	resp, err := c.HttpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read body of request: %w", err)
	}

	var mResp SubscribeToNotificationsResp
	if err = json.Unmarshal(body, &mResp); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	switch mResp.Status {
	case 0:
		return &mResp, nil
	default:
		return &mResp, fmt.Errorf("api returned an error: %s", mResp.APIError)
	}
}

// GetNotificationParam is the parameter needed to get the last notification service the user was subscribed to.
type GetNotificationParam struct {
	// The notification category. Please see the API for the proper values.
	Appli int

	// The URL that the Withings service will call to send the notification.
	CallbackURL url.URL
}

// GetNotificationResp is the response type returned by the Withings API when getting a notification.
// TODO replace the interface once we know what the API really provides. The API docs are not complete.
type GetNotificationResp struct {
	Status   int64        `json:"status"`
	APIError string       `json:"error"`
	Body     Notification `json:"body"`
}

// UpdateQuery updates the query provided with the parameters of this param. The parameters require the ClientID
// of the client subscribing.
func (p *GetNotificationParam) UpdateQuery(q url.Values) url.Values {
	// Constructing the query parameters based on the param provided.
	q.Set("action", APIActionNotificationGet)
	q.Set("callbackurl", p.CallbackURL.String())

	return q
}

// SubscribeToNotifications subscribes to receiving notifications for various events. If the subscription is successful
// the error will be nil.
func (c *Client) GetNotification(ctx context.Context, token AccessToken, param GetNotificationParam) (*GetNotificationResp, error) {

	// Construct authorized request to request data from the API.
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, APINotify, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to build http request: %w", err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token.AccessToken))

	// Updating the query with the parameters generated by the param provided.
	req.URL.RawQuery = param.UpdateQuery(req.URL.Query()).Encode()

	// Executing the request.
	resp, err := c.HttpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read body of request: %w", err)
	}

	var mResp GetNotificationResp
	if err = json.Unmarshal(body, &mResp); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	switch mResp.Status {
	case 0:
		return &mResp, nil
	default:
		return &mResp, fmt.Errorf("api returned an error: %s", mResp.APIError)
	}
}

// ListNotificationParam is the parameter needed to list the notification configuration for the user.
type ListNotificationParam struct {
	// The notification category. Please see the API for the proper values.
	Appli int
}

// ListNotificationResp is the response type returned by the Withings API when getting a notification.
// TODO replace the interface once we know what the API really provides. The API docs are not complete.
type ListNotificationResp struct {
	Status   int64                `json:"status"`
	APIError string               `json:"error"`
	Body     ListNotificationBody `json:"body"`
}

// ListNotificationBody is the body of the response returned by the Withings API for are request of notifications.
type ListNotificationBody struct {
	Profiles Notifications `json:"profiles"`
}

// Notification is a record of a configured notification for a user as defined by the Withings API.
type Notification struct {
	Appli       int    `json:"appli"`
	Callbackurl string `json:"callbackurl"`
	Expires     int    `json:"expires"`
	Comment     string `json:"comment"`
}

// Notifications is a slice of Notification structs.
type Notifications []Notification

// UpdateQuery updates the query provided with the parameters of this param. The parameters require the ClientID
// of the client subscribing.
func (p *ListNotificationParam) UpdateQuery(q url.Values) url.Values {
	// Constructing the query parameters based on the param provided.
	q.Set("action", APIActionNotificationList)
	q.Set("appli", strconv.Itoa(p.Appli))

	return q
}

// ListNotification lists all notifications the user is subscribed to.
func (c *Client) ListNotification(ctx context.Context, token AccessToken, param ListNotificationParam) (*ListNotificationResp, error) {

	// Construct authorized request to request data from the API.
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, APINotify, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to build http request: %w", err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token.AccessToken))

	// Updating the query with the parameters generated by the param provided.
	req.URL.RawQuery = param.UpdateQuery(req.URL.Query()).Encode()

	// Executing the request.
	resp, err := c.HttpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read body of request: %w", err)
	}

	var mResp ListNotificationResp
	if err = json.Unmarshal(body, &mResp); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	switch mResp.Status {
	case 0:
		return &mResp, nil
	default:
		return &mResp, fmt.Errorf("api returned an error: %s", mResp.APIError)
	}
}

// RevokeNotificationParam is the parameter needed to revoke a configured notification.
type RevokeNotificationParam struct {
	// The notification category. Please see the API for the proper values.
	Appli int

	// The URL that the Withings service will call to send the notification.
	CallbackURL url.URL
}

// RevokeNotificationResp is the response type returned by the Withings API when getting a notification.
// TODO replace the interface once we know what the API really provides. The API docs are not complete.
type RevokeNotificationResp struct {
	Status   int64  `json:"status"`
	APIError string `json:"error"`
}

// UpdateQuery updates the query provided with the parameters of this param. The parameters require the ClientID
// of the client subscribing.
func (p *RevokeNotificationParam) UpdateQuery(q url.Values) url.Values {
	// Constructing the query parameters based on the param provided.
	q.Set("action", APIActionNotificationRevoke)
	q.Set("appli", strconv.Itoa(p.Appli))
	q.Set("callbackurl", p.CallbackURL.String())

	return q
}

// RevokeNotification lists all notifications the user is subscribed to.
func (c *Client) RevokeNotification(ctx context.Context, token AccessToken, param RevokeNotificationParam) (*RevokeNotificationResp, error) {

	// Construct authorized request to request data from the API.
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, APINotify, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to build http request: %w", err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token.AccessToken))

	// Updating the query with the parameters generated by the param provided.
	req.URL.RawQuery = param.UpdateQuery(req.URL.Query()).Encode()

	// Executing the request.
	resp, err := c.HttpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read body of request: %w", err)
	}

	var mResp RevokeNotificationResp
	if err = json.Unmarshal(body, &mResp); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	switch mResp.Status {
	case 0:
		return &mResp, nil
	default:
		return &mResp, fmt.Errorf("api returned an error: %s", mResp.APIError)
	}
}

// UpdateNotificationParam is the parameter needed to update the notification configuration for the user. Only one
// value can be updated at a time. The order of precedence is the order defined in the struct.
type UpdateNotificationParam struct {
	// The notification category. Please see the API for the proper values.
	Appli int

	// The URL that the Withings service will call to send the notification.
	CallbackURL url.URL

	// The new callbackurl
	NewCallbackURL *url.URL

	// The new appli value.
	NewAppli *int

	// The new comment value.
	NewComment *string
}

// UpdateNotificationResp is the response type returned by the Withings API when getting a notification.
// TODO replace the interface once we know what the API really provides. The API docs are not complete.
type UpdateNotificationResp struct {
	Status   int64  `json:"status"`
	APIError string `json:"error"`
}

// UpdateQuery updates the query provided with the parameters of this param. The parameters require the ClientID
// of the client subscribing.
func (p *UpdateNotificationParam) UpdateQuery(q url.Values) url.Values {
	// Constructing the query parameters based on the param provided.
	q.Set("action", APIActionNotificationUpdate)
	q.Set("appli", strconv.Itoa(p.Appli))
	q.Set("callbackurl", p.CallbackURL.String())

	if p.NewCallbackURL != nil {
		q.Set("new_callbackurl", p.CallbackURL.String())
		return q
	}

	if p.NewAppli != nil {
		q.Set("new_appli", strconv.Itoa(*p.NewAppli))
		return q
	}

	if p.NewComment != nil {
		q.Set("comment", *p.NewComment)
		return q
	}

	return q
}

// UpdateNotification lists all notifications the user is subscribed to.
func (c *Client) UpdateNotification(ctx context.Context, token AccessToken, param UpdateNotificationParam) (*UpdateNotificationResp, error) {

	// Construct authorized request to request data from the API.
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, APINotify, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to build http request: %w", err)
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token.AccessToken))

	// Updating the query with the parameters generated by the param provided.
	req.URL.RawQuery = param.UpdateQuery(req.URL.Query()).Encode()

	// Executing the request.
	resp, err := c.HttpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read body of request: %w", err)
	}

	var mResp UpdateNotificationResp
	if err = json.Unmarshal(body, &mResp); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	switch mResp.Status {
	case 0:
		return &mResp, nil
	default:
		return &mResp, fmt.Errorf("api returned an error: %s", mResp.APIError)
	}
}
